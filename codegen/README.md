# jsconschematypes

jsconschematypes is a Java library to generate Java or TypeSctript classes from
standard JSON Schemas.

An online demonstration [is here](https://tryjsonschematypes.appspot.com/#java).

It is written by jimblackler@gmail.com and offered under an
[Apache 2.0 license](https://www.apache.org/licenses/LICENSE-2.0).

It allows Java applications that read JSON data to be type-checked at compile
time, reducing the chances of errors due to misinterpreting the format or
mistyping property names. The generated files will also trigger IDE code
completion, assisting the programmer in writing code that reads the JSON.

It is compatible with the following metaschemas:

*   http://json-schema.org/draft-03/schema#
*   http://json-schema.org/draft-04/schema#
*   http://json-schema.org/draft-06/schema#
*   http://json-schema.org/draft-07/schema#
*   https://json-schema.org/draft/2019-09/schema

The classes created by jsonschematypes are wrappers around the official JSON
classes
[`org.json.JSONObject`](https://www.javadoc.io/doc/org.json/json/20171018/org/json/JSONObject.html)
and
[`org.json.JSONArray`](https://www.javadoc.io/doc/org.json/json/20171018/org/json/JSONArray.html)

That approach makes it an alternative to using a library like
[jsonschema2pojo](https://github.com/joelittlejohn/jsonschema2pojo) that enables
deserialization of a JSON string into a tree of generated Java objects. The
approach can generally only support a subset of JSON Schema. If more complex
schema elements not understood by the generator - such as `anyOf` - are used,
parts of the schema are not included in the generated class, making parts of the
loaded JSON data invisible to the Java code reading the data in the best case.
In the worst case the entire data tree is unreadable.

As jsonschematypes does not peform any deserialization itself, but defers that
to the the `org.json` library, it is guaranteed that a whole JSON object can be
read. The classes include methods `getJsonObject()` and `getJsonArray()` that
allow the Java application to fall back to unstructured access whenever
necessary or desired. Neccessary in the case of a complex schema structure being
infeasible for the class generator to adapt, and desired in the case of
gradually adapting a standard Java app that uses `org.json` types to using the
structured classes generated by jsonschematypes.

# Example

The following JSON schema...

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "properties": {
    "firstName": {
      "type": "string"
    },
    "age": {
      "type": "integer"
    }
  },
  "required": ["firstName", "age"]
}
```

... would result in the following generated Java code.

```java
package org.example;

import org.json.JSONObject;

public class Person {

  private final JSONObject jsonObject;

  public Person(JSONObject jsonObject) {
    this.jsonObject = jsonObject;
  }

  public JSONObject getJSONObject() {
    return jsonObject;
  }

  public String getFirstName() {
    return jsonObject.getString("firstName");
  }

  public int getAge() {
    return jsonObject.getInt("age");
  }
}
```

By constructing a new `Person` object and passing in an existing `JSONObject`, a
program can access the data, pass and store it, and maintain greater type safety
and code clarify than handling a raw `JSONObject`.

## Design

Classes are created according to the design of the JSON Schema from which they
are derived. The library takes some license in creating Java classes that match
the inferred intent of the schema, to make them relatively lightweight and not
overwhelming humans to read. This means tactcialy omitting some varations of
accessors that could potentially be supplied. For example, if a schema specifies
a default value for a property, no `has` method will be generated to test for
the presence of that property on an object, since a value can always be
returned. The effect of this is that changes to the schema could result in
methods being removecd from generated Java classes.

Where the generator cannot any useful accessors, no class is generated and the
containing class will supply `JSONObject`s directly.

The generated classes are designed to be as close as possible to idiomatic Java
as possible. For example, using `is` getters such as `isEnabled` when exposing
booleans.

They are *not* designed to hide or completely abstract the fact that the objects
they interface are backed by `JSONObject`s and `JSONArray`s. It is a goal of the
library that programmers can switched to unstructured access (via the usual JSON
accessors) of data where required.

## Implementation

The library uses the `net.jimblackler.jsonschemafriend` Schema loader/validator
to help interpret the schemas and their structure.
